#!/usr/bin/env ruby

require 'optparse'
require_relative '../lib/environment_light.rb'

RAILS_ROOT = File.expand_path('../..', __FILE__).freeze
SIDEKIQ_EXECUTABLE = File.join(RAILS_ROOT, 'bin/sidekiq').freeze

# Parse options
def parse_options
  options = {environment: 'production',
             workdir: Dir.pwd,
             timeout: 15}
  OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename(__FILE__)} [options]"

    opts.on('-eMANDATORY', '--environment=MANDATORY',
            "Set Rails environment (default: #{options[:environment]})") do |e|
      options[:environment] = e
    end

    opts.on('-wMANDATORY', '--workdir=MANDATORY',
            'Set work directory (default: CWD)') do |w|
      options[:workdir] = w
    end

    opts.on('-tMANDATORY', '--timeout=MANDATORY',
            'Set timeout in seconds until sidekiq jobs are killed at '\
            "sidekiq shutdown (default: #{options[:timeout]})") do |t|
      options[:timeout] = t
    end
  end.parse!
  options
end

def run_process(options, arguments, name)
  Process.spawn(SIDEKIQ_EXECUTABLE, *arguments,
                '--environment', options[:environment],
                '--timeout', options[:timeout].to_s,
                '--pidfile', "#{File.join(options[:workdir], name)}.pid",
                '--logfile', "#{File.join(options[:workdir], name)}.log")
end

def hets_queue_thread_count
  # One thread per configured hets instance, minus one for the sequential queue.
  [1, Settings.hets.instance_urls.size - 1].max
end

options = parse_options
pids = {}
processes =
  {hets: %W(--queue prioirty_push,25
            --queue hets,5
            --queue hets-migration,1
            --concurrency #{hets_queue_thread_count}),
   sequential: %W(--queue sequential
                  --concurrency 1),
   default: %w(--queue default
               --queue hets_load_balancing
               --concurrency 5)}

# USR1: terminate in the near future
# USR2: reopen logs
# TERM: terminate in the near future, at most after `timeout` seconds
%w(USR1 USR2 TERM).each do |signal|
  Signal.trap(signal) do
    pids.each do |name, pid|
      $stdout.puts "Sending #{signal} to sidekiq-#{name}..."
      Process.kill(signal, pid)
    end
  end
end

processes.each do |name, arguments|
  pids[name] = run_process(options, arguments, "sidekiq-#{name}")
end
pids.each do |name, pid|
  Process.wait(pid)
end
